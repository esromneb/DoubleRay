<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Emscripten-Generated Code</title>
    <style>
      body {
        font-family: arial;
        margin: 0;
        padding: none;
      }

      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      div.emscripten { text-align: center; }      
      div.emscripten_border { border: 1px solid black; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; background-color: black; }

      #emscripten_logo {
        display: inline-block;
        margin: 0;
      }

      .spinner {
        height: 30px;
        width: 30px;
        margin: 0;
        margin-top: 20px;
        margin-left: 20px;
        display: inline-block;
        vertical-align: top;

        -webkit-animation: rotation .8s linear infinite;
        -moz-animation: rotation .8s linear infinite;
        -o-animation: rotation .8s linear infinite;
        animation: rotation 0.8s linear infinite;

        border-left: 5px solid rgb(235, 235, 235);
        border-right: 5px solid rgb(235, 235, 235);
        border-bottom: 5px solid rgb(235, 235, 235);
        border-top: 5px solid rgb(120, 120, 120);
        
        border-radius: 100%;
        background-color: rgb(189, 215, 46);
      }

      @-webkit-keyframes rotation {
        from {-webkit-transform: rotate(0deg);}
        to {-webkit-transform: rotate(360deg);}
      }
      @-moz-keyframes rotation {
        from {-moz-transform: rotate(0deg);}
        to {-moz-transform: rotate(360deg);}
      }
      @-o-keyframes rotation {
        from {-o-transform: rotate(0deg);}
        to {-o-transform: rotate(360deg);}
      }
      @keyframes rotation {
        from {transform: rotate(0deg);}
        to {transform: rotate(360deg);}
      }

      #status {
        display: inline-block;
        vertical-align: top;
        margin-top: 30px;
        margin-left: 20px;
        font-weight: bold;
        color: rgb(120, 120, 120);
      }

      #progress {
        height: 20px;
        width: 300px;
      }

      #controls {
        display: inline-block;
        float: right;
        vertical-align: top;
        margin-top: 30px;
        margin-right: 20px;
      }

      #output {
        width: 100%;
        height: 200px;
        margin: 0 auto;
        margin-top: 10px;
        border-left: 0px;
        border-right: 0px;
        padding-left: 0px;
        padding-right: 0px;
        display: block;
        background-color: black;
        color: white;
        font-family: 'Lucida Console', Monaco, monospace;
        outline: none;
      }
    </style>

  <script src="jquery-3.4.1.min.js"></script>
  <script src="LoadSave.js"></script>
  <script type="text/javascript" src="LZWEncoder.js"></script>
  <script type="text/javascript" src="NeuQuant.js"></script>
  <script type="text/javascript" src="GIFEncoder.js"></script>
  <script type="text/javascript" src="b64.js"></script>

  <script type="text/javascript">
    var encoder;
    var context;
    function onLoadSetupGif() {

      var cv = document.getElementById('canvas');


      context = cv.getContext('2d');

      encoder = new GIFEncoder();

      encoder.setRepeat(0); //0  -> loop forever
      encoder.setDelay(900); //go to next frame every n milliseconds

      encoder.start();

    }

    function saveGifFrame() {
      encoder.addFrame(context);
    }

    function downloadGif() {
      encoder.finish();
      encoder.download("download.gif");
    }

  </script>


  <script type="text/javascript">
    
    /// Fucking emscripten is blocking us again
    /// we want text boxes we can edit on this page
    /// because emscripten calls addEventListener() with a lambda, there is no way for us to remove this
    /// so we are forced to attach a listner first, and then use stopImmediatePropagation to stop the emscripten
    /// lisnter from firing

    ['keydown', 'keyup', 'keypress', 'blur', 'visibilitychange'].forEach(function(event) {
      document.addEventListener(event, function(event) {
        // console.log('addeventlis2 ' + event.type);
        event.stopImmediatePropagation();
      });
    });

  </script>

  <script type="text/javascript">

    function onLoadRender() {
      // jsPrint('Window OnLoad');
      setupEngineClick();
      parseAndRender();
      // doRenderOfficialClick();
    }

    // there can only be one of these
    // if we want to add more just add to the list of functions
    window.onload = ()=>{
      onLoadSetupGif();
      onLoadRender();
    };
  </script>

  </head>
  <body>
    <script type="text/javascript">


      function doRenderOfficialClick() {
        postCustomMessage({type:'call',fn:'doRenderOfficial',rt:'void'});
      }

      function setupEngineClick() {
        postCustomMessage({type:'call',fn:'setupEngine',rt:'void'});
      }

      function nextRainbowClick() {
        postCustomMessage({type:'call',fn:'renderNextRainbow',rt:'void'});
      }


      function coutIntClick() {
        postCustomMessage({type:'call',fn:'coutInt',rt:'void',at:['number'],av:[4]});
      }

      function coutIntDualClick() {
        postCustomMessage({type:'call',fn:'coutIntDual',rt:'void',at:['number','number'],av:[5,6]});
      }

      function dumpPoly(n) {
        postCustomMessage({type:'call',fn:'dumpPoly',rt:'void',at:['number'],av:[n]});
      }

      function addVec3Signature(vin, n) {
        var vin2 = typeof vin !== 'undefined' ? vin : [];
        var n2 = typeof n !== 'undefined' ? n : 1;

        for(let i = 0; i < n2; i++) {

          vin2.push('number');
          vin2.push('number');
          vin2.push('number');
        }

        return vin2;
      }

      function addNumberSignature(vin, n) {
        var vin2 = typeof vin !== 'undefined' ? vin : [];
        var n2 = typeof n !== 'undefined' ? n : 1;

        for(let i = 0; i < n2; i++) {
          vin2.push('number');
        }

        return vin2;
      }

      function setCamera(location, direction, rotation) {
        if( !Array.isArray(location) || location.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        if( !Array.isArray(direction) || direction.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        if( !Array.isArray(rotation) || rotation.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        const sig = addVec3Signature([],3);

        const args = [location,direction,rotation].flat();

        postCustomMessage({type:'call',fn:'setCamera',rt:'void',at:sig,av:args});
      }

      function setDepth(val) {
        postCustomMessage({type:'call',fn:'setDepth',rt:'void',at:['number'],av:[val]});
      }

      function setAmbientColor(color) {
        if( !Array.isArray(color) || color.length != 3 ) {
          console.log("Illegal argument passed to setAmbientColor()");
          return;
        }

        const sig = addVec3Signature([],1);

        const args = [color].flat();

        postCustomMessage({type:'call',fn:'setAmbientColor',rt:'void',at:sig,av:args});
      }

      function setGlobalC(val) {
        postCustomMessage({type:'call',fn:'setGlobalC',rt:'void',at:['number'],av:[val]});
      }

      function setSphereCount(val) {
        postCustomMessage({type:'call',fn:'setSphereCount',rt:'void',at:['number'],av:[val]});
      }

      function setSphere(
        index,
        radius,
        location,
        ambient,
        specular,
        reflected,
        transmitted,
        diffuse,
        n,
        refraction
        ) {

        if( !Array.isArray(location) || location.length != 3 ) {
          console.log("Illegal argument passed to setSphere()");
          return;
        }

        if( !Array.isArray(diffuse) || diffuse.length != 3 ) {
          console.log("Illegal argument passed to setSphere()");
          return;
        }

        const argc = 
            1   // index
          + 1   // radius
          + 3   // location
          + 1   // ambient
          + 1   // specular
          + 1   // reflected
          + 1   // transmitted
          + 3   // diffuse
          + 1   // n
          + 1;  // refraction

        const sig = addNumberSignature([],argc);

        const args = [index,radius,location,ambient,specular,reflected,transmitted,diffuse,n,refraction].flat();

        postCustomMessage({type:'call',fn:'setSphere',rt:'void',at:sig,av:args});

      }

      function testSphere() {
        setSphere(
          0,
          1.1,
          [1, 0, 3],
          0.1,
          0.2,
          0.3,
          0.4,
          [1, 0.8, 0],
          8);
      }

      function setLightCount(val) {
        postCustomMessage({type:'call',fn:'setLightCount',rt:'void',at:['number'],av:[val]});
      }

      function setLight(
        index,
        direction,
        color
        ) {

        if( !Array.isArray(direction) || direction.length != 3 ) {
          console.log("Illegal argument passed to setLight()");
          return;
        }

        if( !Array.isArray(color) || color.length != 3 ) {
          console.log("Illegal argument passed to setLight()");
          return;
        }

        const argc = 
            1   // index
          + 3   // direction
          + 3;  // color

        const sig = addNumberSignature([],argc);

        const args = [index,direction,color].flat();

        postCustomMessage({type:'call',fn:'setLight',rt:'void',at:sig,av:args});

      }


      function setupOrbit(val) {
        postCustomMessage({type:'call',fn:'setupOrbit',rt:'void',at:['number'],av:[val]});
      }

      function nextOrbitRender() {
        postCustomMessage({type:'call',fn:'nextOrbitRender',rt:'void'});
      }

      function dumpCamera() {
        postCustomMessage({type:'call',fn:'dumpCamera',rt:'void'});
      }

      function chokeOutput(a,b,c,d) {


        const sig = addNumberSignature([],4);

        const args = [a,b,c,d].flat();

        postCustomMessage({type:'call',fn:'chokeOutput',rt:'void',at:sig,av:args});
      }

      function setPrint(val) {
        postCustomMessage({type:'call',fn:'setPrint',rt:'void',at:['number'],av:[val]});
      }



    </script>
    <table>
<td valign="top">
<!--
<input type="button" value="Render" onclick="renderClick()"/><br>
<input type="button" value="RenderDebug" onclick="renderDebugClick()"/><br>
<input type="button" value="SetScale" onclick="setScaleClick()"/>
<input type="text" value="0.006" id="scaleText"/>
<input type="button" value="debug2()" onclick="debug2Click()"/><br>
<br>
<br>
-->
<input type="button" value="Setup Engine" onclick="setupEngineClick()"/><br>
<input type="button" value="Render Official" onclick="doRenderOfficialClick()"/><br>
<br>
<br>
<input type="button" value="Next Rainbow" onclick="nextRainbowClick()"/><br>
<input type="button" value="Cout from C++" onclick="coutIntClick()"/><br>
<input type="button" value="Cout from C++ dual" onclick="coutIntDualClick()"/><br>
<input type="button" value="Dump Poly 0" onclick="dumpPoly(0)"/><br>
<input type="button" value="Safe Gif Frame" onclick="saveGifFrame()"/><br>
<input type="button" value="Download Gif" onclick="downloadGif()"/><br>
</td><td>

<div class="square"></div>
<img src="https://en.js.cx/clipart/ball.svg" id="ball">


</td><td>
<textarea id="jsonscene" rows="13" cols="50">
{
  "camera": {
    "loc": [0, 0, -10],
    "dir": [0, 0, 1],
    "rot": [0, 1, 0],
    "depth": 3
  },
  "global": {
    "color": [0.4, 0.4, 0.4],
    "c": 7
  },
  "spheres": [{
      "rad": 1.1,
      "loc": [1, 0, 0],
      "ambient": 0.4,
      "specular": 0.1,
      "reflected": 0.0,
      "transmitted": 0.0,
      "diffuse": [0.0, 1, 0],
      "n": 8
    },
    {
      "rad": 0.7,
      "loc": [-1, 0, 0],
      "ambient": 0.0,
      "specular": 0.03,
      "reflected": 1,
      "transmitted": 0.0,
      "diffuse": [1, 0.8, 0],
      "n": 7
    },
    {
      "rad": 10,
      "loc": [0, -11, 0],
      "ambient": 0.4,
      "specular": 0.0,
      "reflected": 1,
      "transmitted": 0.0,
      "diffuse": [0, 0.0, 0],
      "n": 11
    }
  ],
  "lights": [{
    "dir": [0, -1, -0.5],
    "color": [10, 10, 10]
  }]
}
</textarea><br>
</td><td>
<input type="button" value="Save Scene" onclick="globalSave('default')"/><br>
<input type="button" value="Load Scene" onclick="globalLoad('default');parseAndRender();"/><br>
</td>
<!-- <td>
<input type="text" id="dtext">
</td> -->

</tr></table>


    <style>
    #ball {
      cursor: pointer;
      width: 25px;
      height: 25px;
    }
    .square {
        height: 200px;
        width: 200px;
        background-color: #333;
      }
    </style>

<script type="text/javascript">

  function parseAndRender() {
    // jsPrint('parseAndRender called ' + new Date());

    const scene = $('#jsonscene').val();

    doJsonParse(scene);
  }

  /// will call sub functions and eventually render the scene
  /// if there are no errors in the input
  function doJsonParse(scene) {
    let obj;
    try {
      obj = JSON.parse(scene);
    } catch(e) {
      jsPrint("ERROR: illegal json");
      jsPrint(e.toString());
      return;
    }

    doJsonCalls(obj);
  }

  ///
  /// Looks at the parsed object and verifies all keys are there
  /// makes all the c calls and then renders at the end
  /// NOTE we may modify obj as we parse through due to default values
  /// etc. (obj remains modified after the call to this function)
  function doJsonCalls(obj) {
    if(obj.camera) {
      const camera = obj.camera;
      if( 
        typeof(camera.loc) !== 'undefined' && 
        typeof(camera.dir) !== 'undefined' &&
        typeof(camera.rot) !== 'undefined' &&
        typeof(camera.depth) !== 'undefined' ) {
        setCamera(camera.loc, camera.dir, camera.rot);
        setDepth(camera.depth);
      } else {
        jsPrint("Camera tree missing required keys");
        return;
      }
    } else {
      jsPrint("Camera tree missing");
      return;
    }

    if(obj.global) {
      const gg = obj.global;
      if( typeof(gg.color) !== 'undefined' && typeof(gg.c) !== 'undefined' ) {
        setAmbientColor(gg.color);
        setGlobalC(gg.c);
      } else {
        jsPrint("Global tree missing required keys");
        return;
      }
    } else {
      jsPrint("Global tree missing");
      return;
    }

    if(obj.spheres) {
      setSphereCount(0); // will delete all spheres in vector
      
      const spheres = obj.spheres;
      setSphereCount(spheres.length); // prevents multiple resizes of vector in c++

      for(let i = 0; i < spheres.length; i++ ) {
        const s = spheres[i];
        if(
         typeof(s.rad) !== 'undefined' &&
         typeof(s.loc) !== 'undefined' &&
         typeof(s.ambient) !== 'undefined' &&
         typeof(s.specular) !== 'undefined' &&
         typeof(s.reflected) !== 'undefined' &&
         typeof(s.transmitted) !== 'undefined' &&
         typeof(s.diffuse) !== 'undefined' &&
         typeof(s.n) !== 'undefined' ) {

         if(typeof(s.refraction) === 'undefined') {
          s.refraction = 1.0;
         }

         setSphere(
           i,
           s.rad,
           s.loc,
           s.ambient,
           s.specular,
           s.reflected,
           s.transmitted,
           s.diffuse,
           s.n,
           s.refraction);

        } else {
          jsPrint("Sphere #" + i + " missing required keys");
        }
      }

        
    } else {
      // spheres tree missing
      // we assume the users just doesn't want any spheres
      setSphereCount(0); // will delete all spheres in vector
    }

    if(obj.lights) {
      setLightCount(0); // will delete all lights in vector
      
      const lights = obj.lights;
      setLightCount(lights.length); // prevents multiple resizes of vector in c++

      for(let i = 0; i < lights.length; i++ ) {
        const s = lights[i];
        if(
         typeof(s.dir) !== 'undefined' &&
         typeof(s.color) !== 'undefined' ) {
          setLight(
            i,
            s.dir,
            s.color
            );

        } else {
          jsPrint("Light #" + i + " missing required keys");

          // c++ will segfault unless we give "legal" default light
          setLight(
            i,
            [1,0,0],
            [0,0,0]
            );
        }
      }

    } else {
      // spheres tree missing
      // we assume the users just doesn't want any spheres
      setLightCount(0); // will delete all lights in vector
    }

    doRenderOfficialClick();
  }


  let changeTimer = null;

  // how many ms after final keypress do we render scene?
  const jsonChangeTimeout = 333;

  $(document).ready(()=>{


    ///
    /// Any time a key is pressed run this
    /// This will fire a timer after N ms to parse and update the
    /// scene, however we eat any repeat keypresses that happen
    /// faster than the timeout
    $('#jsonscene').bind('input propertychange', ()=>{
      // jsPrint('text changed');
      if( changeTimer !== null ) {
        clearTimeout(changeTimer);
      }
      changeTimer = setTimeout(parseAndRender, jsonChangeTimeout);
    });
  });
</script>

<script type="text/javascript">
  // js for UI controls
    let currentDroppable = null;

    // unused for now
    function getDocumentOffsetPosition(el) {
      var position = {
          top: el.offsetTop,
          left: el.offsetLeft
      };
      if (el.offsetParent) {
          var parentPosition = getDocumentOffsetPosition(el.offsetParent);
          position.top += parentPosition.top;
          position.left += parentPosition.left;
      }
      return position;
  }

    ball.onmousedown = function(event) {

      let shiftX = event.clientX - ball.getBoundingClientRect().left;
      let shiftY = event.clientY - ball.getBoundingClientRect().top;

      ball.style.position = 'absolute';
      ball.style.zIndex = 1000;
      document.body.append(ball);

      moveAt(event.pageX, event.pageY);

      function moveAt(pageX, pageY) {
        ball.style.left = pageX - shiftX + 'px';
        ball.style.top = pageY - shiftY + 'px';
      }

      function onMouseMove(event) {
        moveAt(event.pageX, event.pageY);

        /*
        ball.hidden = true;
        let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
        ball.hidden = false;

        if (!elemBelow) return;

        let droppableBelow = elemBelow.closest('.droppable');
        if (currentDroppable != droppableBelow) {
          if (currentDroppable) { // null when we were not over a droppable before this event
            leaveDroppable(currentDroppable);
          }
          currentDroppable = droppableBelow;
          if (currentDroppable) { // null if we're not coming over a droppable now
            // (maybe just left the droppable)
            enterDroppable(currentDroppable);
          }
        }

        */
      }

      document.addEventListener('mousemove', onMouseMove);

      ball.onmouseup = function() {
        document.removeEventListener('mousemove', onMouseMove);
        ball.onmouseup = null;
      };

    };

    // function enterDroppable(elem) {
    //   elem.style.background = 'pink';
    // }

    // function leaveDroppable(elem) {
    //   elem.style.background = '';
    // }

    ball.ondragstart = function() {
      return false;
    };

    function floatBall() {
      let shiftX = window.scrollX + ball.getBoundingClientRect().left;
      let shiftY = window.scrollY + ball.getBoundingClientRect().top;

      ball.style.position = 'absolute';
      ball.style.zIndex = 1000;
      document.body.append(ball);

      ball.style.left = shiftX + 'px';
      ball.style.top  = shiftY + 'px';

    }

    setTimeout(()=>{
      floatBall();
    }, 0);



</script>


    <div class="spinner" id='spinner'></div>
    <div class="emscripten" id="status">Downloading...</div>
<!--
<span id='controls'>
  <span><input type="checkbox" id="resize">Resize canvas</span>
  <span><input type="checkbox" id="pointerLock" checked>Lock/hide mouse pointer &nbsp;&nbsp;&nbsp;</span>
  <span><input type="button" value="Fullscreen" onclick="Module.requestFullscreen(document.getElementById('pointerLock').checked, 
                                                                            document.getElementById('resize').checked)">
  </span>
</span>
-->

    <div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>
    </div>

    
    <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div>
    <textarea id="output" rows="8"></textarea>

    <script type='text/javascript'>
      var statusElement = document.getElementById('status');
      var progressElement = document.getElementById('progress');
      var spinnerElement = document.getElementById('spinner');

      var Module = {
        preRun: [],
        postRun: [],
        print: (function() {
          var element = document.getElementById('output');
          if (element) element.value = ''; // clear browser cache
          return function(text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            console.log(text);
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight; // focus on bottom
            }
          };
        })(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          console.error(text);
        },
        canvas: (function() {
          var canvas = document.getElementById('canvas');

          // As a default initial behavior, pop up an alert when webgl context is lost. To make your
          // application robust, you may want to override this behavior before shipping!
          // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

          return canvas;
        })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) spinnerElement.style.display = 'none';
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
      window.onerror = function(event) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus('Exception thrown, see JavaScript console');
        spinnerElement.style.display = 'none';
        Module.setStatus = function(text) {
          if (text) Module.printErr('[post-exception status] ' + text);
        };
      };

      /// copied from print above
      /// NOTE: we stripped the caching of getElementById() from above
      /// making this function much slower
      function jsPrint(x) {
          var element = document.getElementById('output');
          // if (element) element.value = ''; // clear browser cache

          const inner = (text) => {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            console.log(text);
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight; // focus on bottom
            }
          }

          inner('JS: ' + x);
        }

    </script>
    {{{ SCRIPT }}}
  </body>
</html>


