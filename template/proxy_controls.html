<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Emscripten-Generated Code</title>
    <style>
      body {
        font-family: arial;
        margin: 0;
        padding: none;
      }

      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      div.emscripten { text-align: center; }      
      div.emscripten_border { border: 1px solid black; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; background-color: black; }

      #emscripten_logo {
        display: inline-block;
        margin: 0;
      }

      .spinner {
        height: 30px;
        width: 30px;
        margin: 0;
        margin-top: 20px;
        margin-left: 20px;
        display: inline-block;
        vertical-align: top;

        -webkit-animation: rotation .8s linear infinite;
        -moz-animation: rotation .8s linear infinite;
        -o-animation: rotation .8s linear infinite;
        animation: rotation 0.8s linear infinite;

        border-left: 5px solid rgb(235, 235, 235);
        border-right: 5px solid rgb(235, 235, 235);
        border-bottom: 5px solid rgb(235, 235, 235);
        border-top: 5px solid rgb(120, 120, 120);
        
        border-radius: 100%;
        background-color: rgb(189, 215, 46);
      }

      @-webkit-keyframes rotation {
        from {-webkit-transform: rotate(0deg);}
        to {-webkit-transform: rotate(360deg);}
      }
      @-moz-keyframes rotation {
        from {-moz-transform: rotate(0deg);}
        to {-moz-transform: rotate(360deg);}
      }
      @-o-keyframes rotation {
        from {-o-transform: rotate(0deg);}
        to {-o-transform: rotate(360deg);}
      }
      @keyframes rotation {
        from {transform: rotate(0deg);}
        to {transform: rotate(360deg);}
      }

      #status {
        display: inline-block;
        vertical-align: top;
        margin-top: 30px;
        margin-left: 20px;
        font-weight: bold;
        color: rgb(120, 120, 120);
      }

      #progress {
        height: 20px;
        width: 300px;
      }

      #controls {
        display: inline-block;
        float: right;
        vertical-align: top;
        margin-top: 30px;
        margin-right: 20px;
      }

      #output {
        width: 100%;
        height: 200px;
        margin: 0 auto;
        margin-top: 10px;
        border-left: 0px;
        border-right: 0px;
        padding-left: 0px;
        padding-right: 0px;
        display: block;
        background-color: black;
        color: white;
        font-family: 'Lucida Console', Monaco, monospace;
        outline: none;
      }
    </style>

  <script src="jquery-3.4.1.min.js"></script>
  <script src="LoadSave.js"></script>
  <script type="text/javascript" src="LZWEncoder.js"></script>
  <script type="text/javascript" src="NeuQuant.js"></script>
  <script type="text/javascript" src="GIFEncoder.js"></script>
  <script type="text/javascript" src="b64.js"></script>

  <script type="text/javascript">
    var encoder;
    var context;
    function onLoadSetupGif() {

      var cv = document.getElementById('canvas');


      context = cv.getContext('2d');

      encoder = new GIFEncoder();

      encoder.setRepeat(0); //0  -> loop forever
      encoder.setDelay(100); //go to next frame every n milliseconds

      encoder.start();

    }

    function saveGifFrame() {
      encoder.addFrame(context);
    }

    function downloadGif() {
      encoder.finish();
      encoder.download("download.gif");
    }

  </script>

  <script type="text/javascript">
    var doPublicRender = false;
    if( doPublicRender ) {
      $(document).ready(()=>{
        ['setupEngineButton','coutButton','coutDualButton','dumpPolyButton'].forEach(function(b){
          $('#'+b).remove();
        });
      });
    }
  </script>


  <script type="text/javascript">
    
    /// Fucking emscripten is blocking us again
    /// we want text boxes we can edit on this page
    /// because emscripten calls addEventListener() with a lambda, there is no way for us to remove this
    /// so we are forced to attach a listner first, and then use stopImmediatePropagation to stop the emscripten
    /// lisnter from firing

    ['keydown', 'keyup', 'keypress', 'blur', 'visibilitychange'].forEach(function(event) {
      document.addEventListener(event, function(event) {
        // console.log('addeventlis2 ' + event.type);
        event.stopImmediatePropagation();
      });
    });

    var requestedX = 400;
    var requestedY = 400;

    ///
    /// Emscripten also binds to all of the mouse events
    /// In this case we don't care, we just want an additional action which is to know
    /// Where we clicked
    ///
    function onLoadHookClick() {

      ['mousedown'].forEach(function(event) {
        Module.canvas.addEventListener(event, function(event) {
          // console.log(event);
          let loc = getEventLocation(this,event);

          const browserY = loc.y;
          const browserX = loc.x;

          const canvasYPixels = requestedY; // FIXME change this

          const canvasY = canvasYPixels - browserY;

          // console.log(loc);
          jsPrint("x: " + browserX + " y: " + canvasY);
        }, true);
      });
    } 




  </script>

  <script type="text/javascript">

    function onLoadRender() {
      // jsPrint('Window OnLoad');
      setupEngineClick();
      parseAndRender();
      // doRenderOfficialClick();
    }

    // there can only be one of these
    // if we want to add more just add to the list of functions
    window.onload = ()=>{
      onLoadSetupGif();
      onLoadRender();
      onLoadHookClick();
    };
  </script>

  </head>
  <body>
    <script type="text/javascript">


      function doRenderOfficialClick() {
        postCustomMessage({type:'call',fn:'doRenderOfficial',rt:'void'});
      }

      function setupEngineClick() {
        postCustomMessage({type:'call',fn:'setupEngine',rt:'void'});
      }

      function nextRainbowClick() {
        postCustomMessage({type:'call',fn:'renderNextRainbow',rt:'void'});
      }


      function coutIntClick() {
        postCustomMessage({type:'call',fn:'coutInt',rt:'void',at:['number'],av:[4]});
      }

      function coutIntDualClick() {
        postCustomMessage({type:'call',fn:'coutIntDual',rt:'void',at:['number','number'],av:[5,6]});
      }

      function dumpPoly(n) {
        postCustomMessage({type:'call',fn:'dumpPoly',rt:'void',at:['number'],av:[n]});
      }

      function addVec3Signature(vin, n) {
        var vin2 = typeof vin !== 'undefined' ? vin : [];
        var n2 = typeof n !== 'undefined' ? n : 1;

        for(let i = 0; i < n2; i++) {

          vin2.push('number');
          vin2.push('number');
          vin2.push('number');
        }

        return vin2;
      }

      function addNumberSignature(vin, n) {
        var vin2 = typeof vin !== 'undefined' ? vin : [];
        var n2 = typeof n !== 'undefined' ? n : 1;

        for(let i = 0; i < n2; i++) {
          vin2.push('number');
        }

        return vin2;
      }

      function setCamera(location, direction, rotation) {
        if( !Array.isArray(location) || location.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        if( !Array.isArray(direction) || direction.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        if( !Array.isArray(rotation) || rotation.length != 3 ) {
          console.log("Illegal argument passed to setCamera()");
          return;
        }

        const sig = addVec3Signature([],3);

        const args = [location,direction,rotation].flat();

        postCustomMessage({type:'call',fn:'setCamera',rt:'void',at:sig,av:args});
      }

      function setDepth(val) {
        postCustomMessage({type:'call',fn:'setDepth',rt:'void',at:['number'],av:[val]});
      }

      function setAmbientColor(color) {
        if( !Array.isArray(color) || color.length != 3 ) {
          console.log("Illegal argument passed to setAmbientColor()");
          return;
        }

        const sig = addVec3Signature([],1);

        const args = [color].flat();

        postCustomMessage({type:'call',fn:'setAmbientColor',rt:'void',at:sig,av:args});
      }

      function setNoHitColor(color) {
        if( !Array.isArray(color) || color.length != 3 ) {
          console.log("Illegal argument passed to setNoHitColor()");
          return;
        }

        const sig = addVec3Signature([],1);

        const args = [color].flat();

        postCustomMessage({type:'call',fn:'setNoHitColor',rt:'void',at:sig,av:args});
      }




      function setGlobalC(val) {
        postCustomMessage({type:'call',fn:'setGlobalC',rt:'void',at:['number'],av:[val]});
      }

      function setSphereCount(val) {
        postCustomMessage({type:'call',fn:'setSphereCount',rt:'void',at:['number'],av:[val]});
      }

      function setSphere(
        index,
        radius,
        location,
        ambient,
        specular,
        reflected,
        transmitted,
        diffuse,
        n,
        refraction
        ) {

        if( !Array.isArray(location) || location.length != 3 ) {
          console.log("Illegal argument passed to setSphere()");
          return;
        }

        if( !Array.isArray(diffuse) || diffuse.length != 3 ) {
          console.log("Illegal argument passed to setSphere()");
          return;
        }

        const argc = 
            1   // index
          + 1   // radius
          + 3   // location
          + 1   // ambient
          + 1   // specular
          + 1   // reflected
          + 1   // transmitted
          + 3   // diffuse
          + 1   // n
          + 1;  // refraction

        const sig = addNumberSignature([],argc);

        const args = [index,radius,location,ambient,specular,reflected,transmitted,diffuse,n,refraction].flat();

        postCustomMessage({type:'call',fn:'setSphere',rt:'void',at:sig,av:args});

      }

      function testSphere() {
        setSphere(
          0,
          1.1,
          [1, 0, 3],
          0.1,
          0.2,
          0.3,
          0.4,
          [1, 0.8, 0],
          8);
      }

      function setLightCount(val) {
        postCustomMessage({type:'call',fn:'setLightCount',rt:'void',at:['number'],av:[val]});
      }

      function setLight(
        index,
        direction,
        color
        ) {

        if( !Array.isArray(direction) || direction.length != 3 ) {
          console.log("Illegal argument passed to setLight()");
          return;
        }

        if( !Array.isArray(color) || color.length != 3 ) {
          console.log("Illegal argument passed to setLight()");
          return;
        }

        const argc = 
            1   // index
          + 3   // direction
          + 3;  // color

        const sig = addNumberSignature([],argc);

        const args = [index,direction,color].flat();

        postCustomMessage({type:'call',fn:'setLight',rt:'void',at:sig,av:args});

      }


      function setupOrbit(val) {
        postCustomMessage({type:'call',fn:'setupOrbit',rt:'void',at:['number'],av:[val]});
      }

      function nextOrbitRender() {
        postCustomMessage({type:'call',fn:'nextOrbitRender',rt:'void'});
      }

      function dumpCamera() {
        postCustomMessage({type:'call',fn:'dumpCamera',rt:'void'});
      }

      function chokeOutput(a,b,c,d) {


        const sig = addNumberSignature([],4);

        const args = [a,b,c,d].flat();

        postCustomMessage({type:'call',fn:'chokeOutput',rt:'void',at:sig,av:args});
      }

      function setPrint(val) {
        postCustomMessage({type:'call',fn:'setPrint',rt:'void',at:['number'],av:[val]});
      }

      function setHighlightPixel(x,y) {
        postCustomMessage({type:'call',fn:'setHighlightPixel',rt:'void',at:['number','number'],av:[x,y]});
      }

      function parseJsonScene(str,andRender) {
        postCustomMessage({type:'call',fn:'parseJsonScene',rt:'void',at:['string','boolean'],av:[str,andRender]});
      }

      function resizeBuffer(x,y) {
        postCustomMessage({type:'call',fn:'resizeBuffer',rt:'void',at:['number','number'],av:[x,y]});
      }

      function resizeCanvas(x,y) {
        postCustomMessage({type:'call',fn:'resizeCanvas',rt:'void',at:['number','number'],av:[x,y]});
      }




    </script>
    <table>
<td valign="top">
<!--
<input type="button" value="Render" onclick="renderClick()"/><br>
<input type="button" value="RenderDebug" onclick="renderDebugClick()"/><br>
<input type="button" value="SetScale" onclick="setScaleClick()"/>
<input type="text" value="0.006" id="scaleText"/>
<input type="button" value="debug2()" onclick="debug2Click()"/><br>
<br>
<br>
-->
<input type="button" id="setupEngineButton" value="Setup Engine" onclick="setupEngineClick()"/><br>
<input type="button" id="renderOfficialButton" value="Render Official" onclick="doRenderOfficialClick()"/><br>
<br>
<br>
<input type="button" id="nextRainbowButton" value="Next Rainbow" onclick="nextRainbowClick()"/><br>
<input type="button" id="coutButton" value="Cout from C++" onclick="coutIntClick()"/><br>
<input type="button" id="coutDualButton" value="Cout from C++ dual" onclick="coutIntDualClick()"/><br>
<input type="button" id="dumpPolyButton" value="Dump Poly 0" onclick="dumpPoly(0)"/><br>
<input type="button" id="saveGifFrameButton" value="Safe Gif Frame" onclick="saveGifFrame()"/><br>
<input type="button" id="downloadGifButton" value="Download Gif" onclick="downloadGif()"/><br>
</td><td>
<textarea id="jsonscene" rows="13" cols="50">
{
  "camera": {
    "loc": [5, 0, 0],
    "dir": [-1, 0, 0],
    "rot": [0, 0, 1],
    "depth": 6
  },
  "global": {
    "color": [0.2, 0.2, 0.2],
    "c": 10,
"scale":166.6666666
  },
  "spheres": [{
      "rad": 1,
      "loc": [-1, 0, 0],
      "ambient": 0.1,
      "specular": 1.46,
      "reflected": 0,
      "transmitted": 0.0,
      "diffuse": [0.9, 0.0, 0.0],
      "n": 32
    },
{
      "rad": 0.3,
      "loc": [-0.1, 0, 1.1],
      "ambient": 0.1,
      "specular": 1.46,
      "reflected": 0,
      "transmitted": 0.0,
      "diffuse": [0.8, 0.8, 0.8],
      "n": 32
    },



    {
      "rad": 10,
      "loc": [-4, 0, -11],
      "ambient": 0.4,
      "specular": 0,
      "reflected": 1,
      "transmitted": 0.0,
      "diffuse": [0.4, 0.4, 0.4],
      "n": 1
    }
  ],
  "lights": [{
    "dir": [-0.4, 0, -1],
    "color": [20, 20, 20]
  }
]
}
</textarea><br>
<select id="loadScenesSel">
</select>
</td><td>
Save or Load a scene (via a cookie).  There is only 1 save slot.<br>
<input type="button" value="Save Scene" onclick="globalSave('default')"/><br>
<input type="button" value="Load Scene" onclick="globalLoad('default');parseAndRender();"/><br>
</td>
<!-- <td>
<input type="text" id="dtext">
</td> -->

</tr></table>




<script type="text/javascript">
var $sel = $("#loadScenesSel");

const ss = [
'<Choose A Scene>',
'color_balls_refraction_1.json',
'color_balls_refraction_2.json',
'color_balls_refraction.json',
'cool_reflection_1.json',
'false_color_reflection_1.json',
'floating_spheres_1.json',
'global_scale_1.json',
'glowing_bomb.json',
'hit_order_1.json',
'orientation_1.json',
'refraction_1.json',
'refraction_2.json',
'refraction_9.json',
'refraction_shadow_1.json',
'refraction_shadow_3.json',
'refraction_shadow_4.json',
'soap_bubble_1.json',
'test_shadow_1.json',
'test_shadow_2.json',
'test_shadow_3.json',
'three_color_balls.json',
'three_color_balls_yellow.json'
];

ss.forEach(function(b){
  $sel.append($("<option />").val('scenes/'+b).text(b));
});
// $sel.append($("<option />").val('scenes/three_color_balls.json').text('scenes/three_color_balls.json'));

$sel.change(function(x){
  const sval = $( this ).val();

  if(sval === 'scenes/<Choose A Scene>') {
    return;
  }

  $.ajax({
    url: sval,
    // url: "scenes/test_shadow_1.json",
    // url: "scenes/refraction_7.json",
    dataType: "text",
    context: {}
  }).done(function(x) {
    // console.log(x);
    // $('#jsonscene').val(JSON.stringify(x, null, 4));
    $('#jsonscene').val(x);
    parseAndRender();
    // $( this ).addClass( "done" );
  });
});
</script>


<script type="text/javascript">

  var parseInJavascript = false;

  function parseAndRender() {
    // jsPrint('parseAndRender called ' + new Date());

    const scene = $('#jsonscene').val();

    if( parseInJavascript ) {

      doJsonParse(scene);
    } else {
      // 
      parseJsonScene(scene, true);
      // doRenderOfficialClick();
      determineCanvas(scene);
    }
  }

  // Parse json ourselves as well and grab canvas resolution
  function determineCanvas(scene) {

    let obj;
    try {
      obj = JSON.parse(scene);
    } catch(e) {
      // jsPrint("ERROR: illegal json");
      // jsPrint(e.toString());
      return;
    }

    if(obj.global) {
      const gg = obj.global;

      if( typeof(gg.x) !== 'undefined' && typeof(gg.y) !== 'undefined' ) {
        requestedX = gg.x;
        requestedY = gg.y;
      } else {
        requestedX = 400;
        requestedY = 400;
      }
    }
  }

  /// will call sub functions and eventually render the scene
  /// if there are no errors in the input
  function doJsonParse(scene) {
    let obj;
    try {
      obj = JSON.parse(scene);
    } catch(e) {
      jsPrint("ERROR: illegal json");
      jsPrint(e.toString());
      return;
    }

    doJsonCalls(obj);
  }

  ///
  /// Looks at the parsed object and verifies all keys are there
  /// makes all the c calls and then renders at the end
  /// NOTE we may modify obj as we parse through due to default values
  /// etc. (obj remains modified after the call to this function)
  function doJsonCalls(obj) {
    if(obj.camera) {
      const camera = obj.camera;
      if( 
        typeof(camera.loc) !== 'undefined' && 
        typeof(camera.dir) !== 'undefined' &&
        typeof(camera.rot) !== 'undefined' &&
        typeof(camera.depth) !== 'undefined' ) {
        setCamera(camera.loc, camera.dir, camera.rot);
        setDepth(camera.depth);
      } else {
        jsPrint("Camera tree missing required keys");
        return;
      }
    } else {
      jsPrint("Camera tree missing");
      return;
    }

    if(obj.global) {
      const gg = obj.global;
      if( (typeof(gg.color) !== 'undefined' || typeof(gg.ambient_color) !== 'undefined') && typeof(gg.c) !== 'undefined' ) {

        const ambient = (typeof(gg.color) !== 'undefined') ? gg.color : gg.ambient_color;

        setAmbientColor(ambient);
        setGlobalC(gg.c);
      } else {
        jsPrint("Global tree missing required keys");
        return;
      }

      if( typeof(gg.nohit_color) !== 'undefined' ) {
        setNoHitColor(gg.nohit_color);
      } else {
        /// default is black
        /// js is responsible for this because if a scene doesn't have a nohit key
        /// we will never set this and the nohit_color from the previous scene will be used
        /// is there a way to make C responsible for this?
        setNoHitColor([0,0,0]);
      }

    } else {
      jsPrint("Global tree missing");
      return;
    }

    if(obj.spheres) {
      setSphereCount(0); // will delete all spheres in vector
      
      const spheres = obj.spheres;
      setSphereCount(spheres.length); // prevents multiple resizes of vector in c++

      for(let i = 0; i < spheres.length; i++ ) {
        const s = spheres[i];
        if(
         typeof(s.rad) !== 'undefined' &&
         typeof(s.loc) !== 'undefined' &&
         typeof(s.ambient) !== 'undefined' &&
         typeof(s.specular) !== 'undefined' &&
         typeof(s.reflected) !== 'undefined' &&
         typeof(s.transmitted) !== 'undefined' &&
         typeof(s.diffuse) !== 'undefined' &&
         typeof(s.n) !== 'undefined' ) {

         if(typeof(s.refraction) === 'undefined') {
          s.refraction = 1.0;
         }

         setSphere(
           i,
           s.rad,
           s.loc,
           s.ambient,
           s.specular,
           s.reflected,
           s.transmitted,
           s.diffuse,
           s.n,
           s.refraction);

        } else {
          jsPrint("Sphere #" + i + " missing required keys");
        }
      }

        
    } else {
      // spheres tree missing
      // we assume the users just doesn't want any spheres
      setSphereCount(0); // will delete all spheres in vector
    }

    if(obj.lights) {
      setLightCount(0); // will delete all lights in vector
      
      const lights = obj.lights;
      setLightCount(lights.length); // prevents multiple resizes of vector in c++

      for(let i = 0; i < lights.length; i++ ) {
        const s = lights[i];
        if(
         typeof(s.dir) !== 'undefined' &&
         typeof(s.color) !== 'undefined' ) {
          setLight(
            i,
            s.dir,
            s.color
            );

        } else {
          jsPrint("Light #" + i + " missing required keys");

          // c++ will segfault unless we give "legal" default light
          setLight(
            i,
            [1,0,0],
            [0,0,0]
            );
        }
      }

    } else {
      // spheres tree missing
      // we assume the users just doesn't want any spheres
      setLightCount(0); // will delete all lights in vector
    }

    doRenderOfficialClick();
  }


  let changeTimer = null;

  // how many ms after final keypress do we render scene?
  const jsonChangeTimeout = 333;

  $(document).ready(()=>{


    ///
    /// Any time a key is pressed run this
    /// This will fire a timer after N ms to parse and update the
    /// scene, however we eat any repeat keypresses that happen
    /// faster than the timeout
    $('#jsonscene').bind('input propertychange', ()=>{
      // jsPrint('text changed');
      if( changeTimer !== null ) {
        clearTimeout(changeTimer);
      }
      changeTimer = setTimeout(parseAndRender, jsonChangeTimeout);
    });
  });
</script>



<script type="text/javascript">
  function getElementPosition(obj) {
    var curleft = 0, curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        } while (obj = obj.offsetParent);
        return { x: curleft, y: curtop };
    }
    return undefined;
}

function getEventLocation(element,event){
    // Relies on the getElementPosition function.
    var pos = getElementPosition(element);
    
    return {
      x: (event.pageX - pos.x),
        y: (event.pageY - pos.y)
    };
}
</script>


    <div class="spinner" id='spinner'></div>
    <div class="emscripten" id="status">Downloading...</div>
<!--
<span id='controls'>
  <span><input type="checkbox" id="resize">Resize canvas</span>
  <span><input type="checkbox" id="pointerLock" checked>Lock/hide mouse pointer &nbsp;&nbsp;&nbsp;</span>
  <span><input type="button" value="Fullscreen" onclick="Module.requestFullscreen(document.getElementById('pointerLock').checked, 
                                                                            document.getElementById('resize').checked)">
  </span>
</span>
-->

    <div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>
    </div>

    
    <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div>
    <textarea id="output" rows="8"></textarea>

    <script type='text/javascript'>
      var statusElement = document.getElementById('status');
      var progressElement = document.getElementById('progress');
      var spinnerElement = document.getElementById('spinner');

      var Module = {
        preRun: [],
        postRun: [],
        print: (function() {
          var element = document.getElementById('output');
          if (element) element.value = ''; // clear browser cache
          return function(text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            console.log(text);
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight; // focus on bottom
            }
          };
        })(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          console.error(text);
        },
        canvas: (function() {
          var canvas = document.getElementById('canvas');

          // As a default initial behavior, pop up an alert when webgl context is lost. To make your
          // application robust, you may want to override this behavior before shipping!
          // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

          return canvas;
        })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) spinnerElement.style.display = 'none';
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
      window.onerror = function(event) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus('Exception thrown, see JavaScript console');
        spinnerElement.style.display = 'none';
        Module.setStatus = function(text) {
          if (text) Module.printErr('[post-exception status] ' + text);
        };
      };

      /// copied from print above
      /// NOTE: we stripped the caching of getElementById() from above
      /// making this function much slower
      function jsPrint(x) {
          var element = document.getElementById('output');
          // if (element) element.value = ''; // clear browser cache

          const inner = (text) => {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            console.log(text);
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight; // focus on bottom
            }
          }

          inner('JS: ' + x);
        }

    </script>
    {{{ SCRIPT }}}
  </body>
</html>


